---
title: Building the UI
---

import DocsCard from '../../src/components/global/DocsCard';
import DocsCards from '../../src/components/global/DocsCards';

Now we're going to work with Contember Interface. It's a React framework for fast custom UI building. Contember Engine can work separately as a GraphQL API, but, it's often used with Interface to quickly build interface for users that need to work with data.

In this example we'll create just a simple UI. But with Interface, you can use any React component. This lets you build almost any single page application. Data binding also makes this very easy and fast.

## Building simple UI

:::note important

Before we start, make sure you already have a Contember project running on your computer. This should be a project with your data model that we made in the [designing your model](/intro/quickstart) guide.

:::

:::tip New

In Interface 1.2 we are introducing new layout with `Slots` and `Directives` which replaces `Pages`. The upgrade is smooth but it gives you way more power. [About new layout](/reference/admin/layouts/overview)

:::

### List all articles

First, we want to create a display for all articles present in our project. To achieve this, we're using the DataGridPage component. This component generates a table, including filters for sorting and searching data.

To start, navigate to admin/pages and create a new file named articleList.tsx.

```tsx title="admin/pages/articleList.tsx"
import * as React from 'react'
import { DataGridPage, TextCell } from '@contember/admin'

export default () => (
  <DataGridPage entities="Article" rendererProps={{ title: 'Articles' }}>
    <TextCell field="title" header="Title" />
  </DataGridPage>
)
```

What we've created here is a page that renders a table listing all the articles in our project. The table includes a column for the title of each article. Let's break down what's happening:

- We begin by importing the @contember/admin package. This package contains all necessary components and also supports TypeScript autocompletion.
- Next, we export the page component as the default export. This is necessary for our routing and navigation.
- We implement the DataGridPage component to display our data in a simple, easy-to-read grid format.
- We specify the entity we want to work with, which in this case is Article. This entity name should match what we defined in our model.
- Lastly, we use the TextCell component to add a text column, designated for the title of each article.

When you navigate to localhost:1480/article-list, you should now see a list of your articles. Keep in mind, this list will be empty if no articles have been added to the data model yet.

### Routing

In addition to the steps above, it's important to note how routing works within this framework:

The naming of pages (and by extension, URL paths) is automated. The name given to a page is determined by the name of the file and the function, with slashes ('/') used as separators.

For example, if you have a default export from a file named `post.tsx`, the resulting page name would be `post`. If there's a function within the same file that's exported as edit, the page name would be `post/edit`.

<DocsCards>
  <DocsCard header="Pages and routing" href="/reference/admin/pages/defining-pages">
    <p>Understand how pages and routing works.</p>
  </DocsCard>
</DocsCards>

### Create an article

```tsx title="admin/pages/articleCreate.tsx"
import * as React from 'react'
import { CreatePage, RichTextField, TextField } from '@contember/admin'

export default () => (
  <CreatePage entity="Article" rendererProps={{ title: 'Create Article' }}>
    <TextField field="title" label="Title" />
    <RichTextField field="content" label="Content" />
  </CreatePage>
)
```

1. We'll create a new file named `articleCreate.tsx`.
2. This time we'll use `CreatePage` component.
3. We'll tell it what we want to add (`Article`).
4. We'll use two new components - `TextField` and `RichTextField` and tell them what fields to edit.

Now at [localhost:1480/article-create](http://localhost:1480/article-create) you can create new article. And if you go to the [list of articles](http://localhost:1480/article-list) you'll see the data are there.

But it doesn't work very well. One of the things missing is to go to edit mode after you created a new article. So let's start by adding an edit page:

### Add edit page

We'll create a new page named `articleEdit`. It looks almost the same as the create page - but we have to tell it which article to edit:

```tsx title="admin/pages/articleEdit.tsx"
import * as React from 'react'
import { EditPage, RichTextField, TextField } from '@contember/admin'

export default () => (
	<EditPage entity="Article(id = $id)" rendererProps={{ title: 'Edit Article' }}>
		<TextField field="title" label="Title" />
		<RichTextField field="content" label="Content" />
	</EditPage>
)
```

Let's use it. We'll redirect users from our create page to the edit page after the article is successfully created:

```tsx title="admin/pages/articleCreate.tsx"
import * as React from 'react'
import { CreatePage, RichTextField, TextField } from '@contember/admin'

export default () => (
  <CreatePage
    entity="Article"
    rendererProps={{ title: 'Create Article' }}
    {/* highlight-start */}
    redirectOnSuccess="articleEdit(id: $entity.id)"
    {/* highlight-end */}
  >
    <TextField field="title" label="Title" />
    <RichTextField field="content" label="Content" />
  </CreatePage>
)
```

This is done with `redirectOnSuccess` prop where we specify link to page where user should be redirected.

Now if you create a new article you're automatically redirected to the edit page.

What's missing is an edit and delete button in the list of pages.

```tsx title="admin/pages/articleList.tsx"
import * as React from 'react'
import { DataGridPage, DeleteEntityButton, GenericCell, Link, TextCell } from '@contember/admin'

export default () => (
  <DataGridPage entities="Article" rendererProps={{ title: 'Articles' }}>
    <TextCell field="title" header="Title" />
    {/* highlight-start */}
    <GenericCell shrunk><Link to="articleEdit(id: $entity.id)">Edit</Link></GenericCell>
    <GenericCell shrunk><DeleteEntityButton immediatePersist /></GenericCell>
    {/* highlight-end */}
  </DataGridPage>
)
```

1. We've added two `GenericCell`.
2. First with `Link` component targeting `articleEdit` page and passing `id` as parameter.
3. Second with delete button provided by `DeleteEntityButton`.
4. Minor touch is use of `shrunk` with tells the cell to be as small as possible.

### Add pages to side menu

One last thing is to add our pages to the left sidebar:

```tsx title="admin/components/Navigation.tsx"
import * as React from 'react'
import { Menu } from '@contember/admin'

export const Navigation = () => (
  <Menu>
    <Menu.Item>
      <Menu.Item title="Dashboard" to="index" />
      <Menu.Item title="Articles" to="articleList" />
      <Menu.Item title="Create new article" to="articleCreate" />
    </Menu.Item>
  </Menu>
)
```

And that's it! You have just created a simple data model and created custom interface, so you can edit the data.

![administration is running](/assets/quickstart-final.png)

## Fetch data via GraphQL API

We recommend reading [Content API topic](/reference/engine/content/overview) however if you're looking to quickly play with the API, we've prepared [Insomnia](https://insomnia.rest/) project for you to import and quickly try it out. To use it <a href="/assets/insomnia-quickstart.json" target="_blank">download it here</a> and just drag&drop it to Insomnia.

## Next steps

- You can [deploy your project to Contember Cloud](/guides/deploy-contember.md).
- Add support for SEO with [our guide](/guides/seo.md).
